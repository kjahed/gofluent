package main

import (
	"bytes"
	"encoding/json"
	"flag"
	"fmt"
	"go/ast"
	"go/token"
	"go/types"
	"os"
	"path/filepath"
	"strings"
	"text/template"
	"unicode"

	"golang.org/x/tools/go/packages"
)

var (
	inPkgsFlag    = flag.String("pkgs", "", "Go packages containing the structs to generate the API for")
	outputDirFlag = flag.String("out", "", "Output dir/pkg for the generated API")
)

type (
	typeAttr struct {
		TypeName        string
		PkgPath         string
		PkgName         string
		DefiningFile    string
		IsPtr           bool
		IsSlice         bool
		IsMap           bool
		IsStruct        bool
		IsFunc          bool
		IsIntf          bool
		SliceValType    *typeAttr
		MapKeyType      *typeAttr
		MapValType      *typeAttr
		FuncParamTypes  []*typeAttr
		FuncResultTypes []*typeAttr
		StructFields    []*fieldAttr
		Implementations []*typeAttr
	}

	fieldAttr struct {
		StructName string
		FieldName  string
		FuncSuffix string
		ValType    *typeAttr
	}

	structAttr struct {
		Pkg        *packages.Package
		TypeSpec   *ast.StructType
		StructName string
	}
)

func (f *fieldAttr) getVariations() []*fieldAttr {
	v := []*fieldAttr{}
	if f.ValType.IsIntf {
		for _, ta := range f.ValType.Implementations {
			v = append(v, &fieldAttr{
				StructName: f.StructName,
				FieldName:  f.FieldName,
				FuncSuffix: "_" + ta.TypeName,
				ValType:    ta,
			})
		}
	} else {
		v = append(v, f)
	}
	return v
}

func (t *typeAttr) String() string {
	s := ""
	if t.IsPtr {
		s += "*"
	}
	if t.IsSlice {
		s += "[]"
		s += t.SliceValType.String()
	} else if t.IsMap {
		s += "map[" + t.MapKeyType.String() + "]" + t.MapValType.String()
	} else if t.IsFunc {
		params := ""
		for i, ta := range t.FuncParamTypes {
			if i > 0 {
				params += ","
			}
			params += ta.String()
		}

		results := ""
		for i, ta := range t.FuncResultTypes {
			if i > 0 {
				results += ","
			}
			results += ta.String()
		}

		s += "func(" + params + ")" + "(" + results + ")"
	} else {
		if t.PkgPath != "" {
			if pkgPrefix, ok := pkgKeys[t.PkgPath]; ok {
				s += pkgPrefix + "."
			}
		}
		s += t.TypeName
	}
	return s
}

func (t *typeAttr) InitString() string {
	if !t.IsSlice && !t.IsMap {
		return ""
	}
	s := ""
	if t.IsPtr {
		s = "&" + t.String()[1:]
	} else {
		s = t.String()
	}
	return s + "{}"
}

const (
	preambleTmpltStr = `
// Code generated by gofluent. DO NOT EDIT.
package {{ .OutPkgName }}
{{- if gt (len .Imports) 0 }}
import (
	{{- range $k, $v := .Imports}}
	{{ $k }} "{{ $v }}"
	{{- end }}
)
{{- end }}
`

	builderTmpltStr = `
type {{ .TypeName }}Builder struct {
	s *{{ qualifiedName . }}
}

func New{{ .TypeName }}() *{{ .TypeName }}Builder {
	b := &{{ .TypeName }}Builder{
		s: &{{ qualifiedName . }}{},
	}
	{{- range .StructFields }} 
	{{- if or .ValType.IsSlice .ValType.IsMap}}
	b.s.{{ .FieldName }} = {{ typeInit .ValType }}
	{{- end }}
	{{- end }}
	return b
}

func (b *{{ .TypeName }}Builder) Build() *{{ qualifiedName . }} {
	return b.s
}
`

	withFuncTmpltStr = `
func (b *{{ .StructName }}Builder) With{{ .FieldName }}{{ .FuncSuffix }}(a {{ .ValType }}) *{{ .StructName }}Builder {
	b.s.{{ .FieldName }} = a
	return b
}
	`

	addFuncTmpltStr = `
func (b *{{ .StructName }}Builder) Add{{ .FieldName }}(a {{ .ValType.SliceValType }}) *{{ .StructName }}Builder {
	b.s.{{ .FieldName }} = append(b.s.{{ .FieldName }}, a)
	return b
}
	`

	putFuncTmpltStr = `
func (b *{{ .StructName }}Builder) Put{{ .FieldName }}(k {{ .ValType.MapKeyType }}, v {{ .ValType.MapValType }}) *{{ .StructName }}Builder {
	b.s.{{ .FieldName }}[k] = v
	return b
}
	`
)

var (
	preambleTmplt *template.Template
	builderTmplt  *template.Template
	withFuncTmplt *template.Template
	addFuncTmplt  *template.Template
	putFuncTmplt  *template.Template

	pkgs          []*packages.Package
	pkgKeys       map[string]string
	pkgLoadConfig *packages.Config
	loadedPkgs    map[string]bool
	targetPkgs    []string
)

func init() {
	var err error

	preambleTmplt, err = template.New("preambleTmplt").Parse(preambleTmpltStr)
	if err != nil {
		die("%v\n", err)
	}

	builderTmplt, err = template.New("builderTmplt").Funcs(template.FuncMap{
		"typeInit": func(t *typeAttr) string {
			return t.InitString()
		},
		"qualifiedName": func(t *typeAttr) string {
			if k, ok := pkgKeys[t.PkgPath]; ok {
				return k + "." + t.TypeName
			}
			return t.TypeName
		},
	}).Parse(builderTmpltStr)
	if err != nil {
		die("%v\n", err)
	}

	withFuncTmplt, err = template.New("withFuncTmplt").Parse(withFuncTmpltStr)
	if err != nil {
		die("%v\n", err)
	}

	addFuncTmplt, err = template.New("addFuncTmplt").Parse(addFuncTmpltStr)
	if err != nil {
		die("%v\n", err)
	}

	putFuncTmplt, err = template.New("putFuncTmplt").Parse(putFuncTmpltStr)
	if err != nil {
		die("%v\n", err)
	}

	pkgLoadConfig = new(packages.Config)
	pkgLoadConfig.Mode = packages.NeedSyntax | packages.NeedTypes | packages.NeedTypesSizes | packages.NeedTypesInfo | packages.NeedName | packages.NeedDeps | packages.NeedImports
	pkgLoadConfig.Fset = token.NewFileSet()
	loadedPkgs = map[string]bool{}
	pkgs = []*packages.Package{}
}

func die(format string, a ...any) {
	fmt.Fprintf(os.Stderr, format, a...)
	os.Exit(1)
}

func prettyPrint(i interface{}) string {
	s, _ := json.MarshalIndent(i, "", "\t")
	return string(s)
}

func main() {
	flag.Parse()
	if *inPkgsFlag == "" {
		die("missing required -pkgs arg\n")
	}
	if *outputDirFlag == "" {
		die("missing required -out arg\n")
	}

	targetPkgs = strings.Split(*inPkgsFlag, ",")
	loadPkgs(targetPkgs...)

	exportedStructs := findExportedStructs(pkgs)
	toGenerate := map[string][]*typeAttr{}

	for _, es := range exportedStructs {
		sAttr := &typeAttr{
			TypeName:     es.StructName,
			PkgPath:      es.Pkg.ID,
			PkgName:      es.Pkg.Name,
			DefiningFile: es.Pkg.Fset.File(es.TypeSpec.Pos()).Name(),
			IsStruct:     true,
			StructFields: []*fieldAttr{},
		}
		if _, ok := toGenerate[es.Pkg.ID]; !ok {
			toGenerate[es.Pkg.ID] = []*typeAttr{}
		}
		toGenerate[es.Pkg.ID] = append(toGenerate[es.Pkg.ID], sAttr)
		fillStructAttr(es.Pkg, es.TypeSpec, sAttr)
	}

	for _, ss := range toGenerate {
		outDir := filepath.Dir(*outputDirFlag)
		outPkg := filepath.Base(outDir)
		outFile := ss[0].PkgName + "_fluent.go"

		imports := collectImports(ss)
		pkgKeys = make(map[string]string)
		for k, v := range imports {
			pkgKeys[v] = k
		}

		os.MkdirAll(outDir, os.ModePerm)

		var buff bytes.Buffer
		if err := preambleTmplt.Execute(&buff, struct {
			OutPkgName string
			Imports    *map[string]string
		}{
			OutPkgName: outPkg,
			Imports:    &imports,
		}); err != nil {
			die("%v\n", err)
		}

		for _, s := range ss {
			if err := builderTmplt.Execute(&buff, s); err != nil {
				die("%v\n", err)
			}

			for _, sf := range s.StructFields {
				for _, fa := range sf.getVariations() {
					if err := withFuncTmplt.Execute(&buff, fa); err != nil {
						die("%v\n", err)
					}
				}

				if sf.ValType.IsSlice {
					if err := addFuncTmplt.Execute(&buff, sf); err != nil {
						die("%v\n", err)
					}
				} else if sf.ValType.IsMap {
					if err := putFuncTmplt.Execute(&buff, sf); err != nil {
						die("%v\n", err)
					}
				}
			}
		}

		if err := os.WriteFile(filepath.Join(outDir, outFile), buff.Bytes(), 0644); err != nil {
			die("%v\n", err)
		}
	}
}

func loadPkgs(path ...string) {
	ps, err := packages.Load(pkgLoadConfig, path...)
	if err != nil {
		die("%v\n", err)
	}

	for _, p := range ps {
		if _, ok := loadedPkgs[p.ID]; !ok {
			pkgs = append(pkgs, p)
			loadedPkgs[p.ID] = true
		}
	}
}

func fillStructAttr(pkg *packages.Package, st *ast.StructType, sAttr *typeAttr) {
	for _, f := range st.Fields.List {
		tAttr := &typeAttr{}
		if !fillTypeAttr(pkg, f.Type, tAttr) {
			continue
		}

		if len(f.Names) == 0 {
			sAttr.StructFields = append(sAttr.StructFields, &fieldAttr{
				StructName: sAttr.TypeName,
				FieldName:  tAttr.TypeName,
				ValType:    tAttr,
			})
		} else {
			for _, n := range f.Names {
				if isNameExported(n.Name) {
					sAttr.StructFields = append(sAttr.StructFields, &fieldAttr{
						StructName: sAttr.TypeName,
						FieldName:  n.Name,
						ValType:    tAttr,
					})
				}
			}
		}
	}
}

func fillTypeAttr(pkg *packages.Package, tExpr ast.Expr, tAttr *typeAttr) bool {
	switch t := tExpr.(type) {
	case *ast.Ident:
		tAttr.TypeName = t.Name
	case *ast.StarExpr:
		tAttr.IsPtr = true
		if !fillTypeAttr(pkg, t.X, tAttr) {
			return false
		}
	case *ast.ArrayType:
		tAttr.IsSlice = true
		tAttr.SliceValType = &typeAttr{}
		if !fillTypeAttr(pkg, t.Elt, tAttr.SliceValType) {
			return false
		}
	case *ast.MapType:
		tAttr.IsMap = true
		tAttr.MapKeyType = &typeAttr{}
		tAttr.MapValType = &typeAttr{}
		if !fillTypeAttr(pkg, t.Key, tAttr.MapKeyType) {
			return false
		}
		if !fillTypeAttr(pkg, t.Value, tAttr.MapValType) {
			return false
		}
	case *ast.FuncType:
		tAttr.IsFunc = true
		tAttr.FuncParamTypes = []*typeAttr{}
		tAttr.FuncResultTypes = []*typeAttr{}

		for _, p := range t.Params.List {
			pAttr := &typeAttr{}
			if !fillTypeAttr(pkg, p.Type, pAttr) {
				return false
			}
			tAttr.FuncParamTypes = append(tAttr.FuncParamTypes, pAttr)
		}

		if t.Results != nil {
			for _, p := range t.Results.List {
				pAttr := &typeAttr{}
				if !fillTypeAttr(pkg, p.Type, pAttr) {
					return false
				}
				tAttr.FuncResultTypes = append(tAttr.FuncResultTypes, pAttr)
			}
		}
	}

	tp := pkg.TypesInfo.Types[tExpr].Type
	if nt, ok := tp.(*types.Named); ok {
		tAttr.TypeName = nt.Obj().Name()
		if nt.Obj().Pkg() != nil {
			tAttr.PkgPath = nt.Obj().Pkg().Path()
			tAttr.PkgName = nt.Obj().Pkg().Name()
			if isInternalPkg(tAttr.PkgPath) {
				return false
			}
			if _, ok := loadedPkgs[tAttr.PkgPath]; !ok {
				loadPkgs(tAttr.PkgPath)
			}
		}

		if !isNameExported(tAttr.TypeName) {
			if it, ok := tp.Underlying().(*types.Interface); ok {
				tAttr.IsIntf = true
				tAttr.Implementations = findImplementations([]*packages.Package{pkg}, it)
				return len(tAttr.Implementations) > 0
			}
			return false
		}
	}
	return true
}

func findExportedStructs(pkgs []*packages.Package) []*structAttr {
	structs := []*structAttr{}
	for _, p := range pkgs {
		for _, ts := range findStructsInPkg(p) {
			if st, ok := ts.Type.(*ast.StructType); ok {
				if !isNameExported(ts.Name.Name) {
					continue
				}

				structs = append(structs, &structAttr{
					StructName: ts.Name.Name,
					Pkg:        p,
					TypeSpec:   st,
				})
			}
		}
	}
	return structs
}

// ita := &typeAttr{
// 	TypeName:     sa.StructName,
// 	PkgPath:      sa.Pkg.ID,
// 	PkgName:      sa.Pkg.Name,
// 	DefiningFile: sa.Pkg.Fset.File(sa.TypeSpec.Pos()).Name(),
// 	IsPtr:        true,
// 	IsStruct:     true,
// }
// if fillTypeAttr(sa.Pkg, sa.TypeSpec, ita) {
// 	tAttr.Implementations = append(tAttr.Implementations, ita)
// }

func findImplementations(pkgs []*packages.Package, intf *types.Interface) []*typeAttr {
	implementations := []*typeAttr{}
	exportedStructs := findExportedStructs(pkgs)
	for _, sa := range exportedStructs {
		st := sa.Pkg.Types.Scope().Lookup(sa.StructName)
		if st != nil {
			tattr := &typeAttr{
				TypeName:     sa.StructName,
				PkgPath:      sa.Pkg.ID,
				PkgName:      sa.Pkg.Name,
				DefiningFile: sa.Pkg.Fset.File(sa.TypeSpec.Pos()).Name(),
				IsStruct:     true,
			}
			fillTypeAttr(sa.Pkg, sa.TypeSpec, tattr)

			if types.Implements(st.Type(), intf) {
				implementations = append(implementations, tattr)
			} else if types.Implements(types.NewPointer(st.Type()), intf) {
				tattr.IsPtr = true
				implementations = append(implementations, tattr)
			}
		}
	}
	return implementations
}

func findStructsInPkg(pkg *packages.Package) []*ast.TypeSpec {
	typeSpecs := []*ast.TypeSpec{}
	for _, syn := range pkg.Syntax {
		for _, f := range syn.Decls {
			gd, ok := f.(*ast.GenDecl)
			if !ok || gd.Tok != token.TYPE {
				continue
			}
			for _, s := range gd.Specs {
				if ts, ok := s.(*ast.TypeSpec); ok {
					if _, ok := ts.Type.(*ast.StructType); ok {
						typeSpecs = append(typeSpecs, ts)
					}
				}
			}
		}
	}
	return typeSpecs
}

func collectImports(t []*typeAttr) map[string]string {
	ret := map[string]string{}
	m := map[string]map[string]bool{}
	for v := range collectRequiredPkgs(t) {
		pkgKey := pkgNameFromPath(v)
		if _, ok := m[pkgKey]; !ok {
			m[pkgKey] = map[string]bool{}
		}
		m[pkgKey][v] = true
	}

	for pkgKey, pkgs := range m {
		i := 0
		for pkgPath := range pkgs {
			if i > 0 {
				ret[fmt.Sprintf("%s_%d", pkgKey, i)] = pkgPath
			} else {
				ret[pkgKey] = pkgPath
			}
			i++
		}
	}
	return ret
}

func collectRequiredPkgs(t []*typeAttr) map[string]bool {
	m := map[string]bool{}
	for _, ta := range t {
		collectRequiredPkgsHelper(ta, &m)
	}
	return m
}

func collectRequiredPkgsHelper(t *typeAttr, m *map[string]bool) {
	if t == nil {
		return
	}
	if t.PkgPath != "" {
		(*m)[t.PkgPath] = true
	}
	collectRequiredPkgsHelper(t.MapKeyType, m)
	collectRequiredPkgsHelper(t.MapValType, m)
	collectRequiredPkgsHelper(t.SliceValType, m)
	for _, ta := range t.FuncParamTypes {
		collectRequiredPkgsHelper(ta, m)
	}
	for _, ta := range t.FuncResultTypes {
		collectRequiredPkgsHelper(ta, m)
	}
	for _, fa := range t.StructFields {
		collectRequiredPkgsHelper(fa.ValType, m)
	}
	for _, ta := range t.Implementations {
		collectRequiredPkgsHelper(ta, m)
	}
}

func pkgNameFromPath(p string) string {
	pkgParts := strings.Split(p, "/")
	return pkgParts[len(pkgParts)-1]
}

func isNameExported(n string) bool {
	return len(n) > 0 && unicode.IsUpper(rune(n[0]))
}

func isInternalPkg(p string) bool {
	return strings.Contains(p, "/internal/")
}
